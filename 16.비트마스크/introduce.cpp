/*
[연산자 종류]
AND(뺄셈) : a & b
OR(덧셈) : a | b
XOR : a ^ b
NOT : ~a
정수 a를 왼쪽으로 b 비트만큼 시프트 : a << b
정수 a를 오른쪽으로 b 비트만큼 시프트 : a >> b

[주의]
비트 연산자의 우선 순위는 (==, != 등)비교 연산자보다 낮다.
int c = (6 & 4 == 4)
int c = ((6 & 4) == 4)


[사용 사례 _ 집합 구현]
 - N 비트 정수 변수는 0 ~ N-1 까지의 정수 원소를 가질 수 있는 집합
 - 이때, 원소 i가 집합에 속해 있는지 여부는 2^i을 나타내는 비트가 켜져 있는지 여부로 나타낸다.

[기본 연산]
 - 공집합 : 상수 0
 - 꽉 판 집합 : (1 << N) - 1
 - 원소 추가 : A |= (1 << p)     //추가하려는 원소의 인덱스가 p 일때
 - 원소의 포함 여부 확인 : if (A & (1 << p)) { do Someting }   //& 연산의 결과는 0 또는 1<<p
 - 원소의 삭제 : A &= ~(1 << p)
 - 토클(스위칭) : A ^= (1 << p)

[두 집합에 대한 연산]
 - 합집합 : int added = (a | b);
 - 교집합 : int intersection = (a & b);
 - 차집합 : int removed = (a & ~b);
 - 둘 중 하나에만 포함된 원소들의 집합 : int toggled = (a ^ b);
 - 집합의 크기
    int bitCount(int x) {
        if (x == 0) return 0;
        return x % 2 + bitCount(x / 2);
    }
 - 최소 원소 찾기 : int first = (A & -A);
 - 최소 원소 지우기 : A &= (A - 1);
 - 모든 부분 집합 순회하기
    for (int subset = A; subset; subset = ((subset-1) & A)) {
        // subset 은 A 의 부분집합
        //(subset-1)을 하면 켜져 있던 최하위 비트가 꺼지고, 그 밑의 비트들은 전부 켜진다.
        //이때, A와의 교집합을 구하면 그 중에서 A에 속하지 않은 비트들은 모두 꺼지게 된다.
        //주의 : 공집합은 방문하지 않는다.
    }

*/

